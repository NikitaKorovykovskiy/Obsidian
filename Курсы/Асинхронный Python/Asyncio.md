Основное преимущество - более эффективный код. Есть способность выполнять конкурентный код и избегать блокировки потока (ожидание ресурсов).

```python
import asyncio
import time


start = time.time()

async def sleeping(n):
    print(f"Начало выполнения длительной операции № {n}: {time.time() - start:.4f}")
    await asyncio.sleep(1)
    print(f"Длительная операция № {n} завершена")

async def main():
    # Запуск 30 задач.
    task = [sleeping(i) for i in range(1, 31)]
    all_results = await asyncio.gather(*task)
    print(f"Выполнено {len(all_results)} операций.")
    print(f"Программа завершена за {time.time() - start:.4f}")

asyncio.run(main())
```
_Все функции и ключевые слова библиотеки `asyncio`, использованные в данном примере, будут подробно рассмотрены в курсе. Поэтому пока предлагаю просто запустить данный код у себя и убедиться, что программа, в которой есть 30 задач длительностью 1 секунду, завершается за время немногим превышающее время выполнения одной задачи._

Время выполнения асинхронных задач занимает время выполнения самой долгой задачи. 
Н-р:
запускаются 3 задачи время выполнения каждой (1сек, 3 сек, 10 сек) - выполнение асинхронного кода займет 10 секунд.