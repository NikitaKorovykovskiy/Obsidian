Основная информация:
- Все 3 изученных термина это части awaitable объектов
- Можно создавать не только функции, но и объекты корутины([[#Пример 1 использование await c корутиной]])
- Вызов объектов корутины через await запустит их как будто синхронно и они выполнятся последовательно ([[#Пример 1 использование await c корутиной]])
- Создание через `task_create()` запустит их параллельно ([[#Пример 2 использование await c объектом `Task`]])

В предыдущих уроках мы рассмотрели 3 типа объектов asyncio:

- объекты корутины
- объекты `Task`
- объекты `Future`

Эти три типа объектов называются **awaitable** объектами. Объединяет то, что их можно использовать с ключевым словом `await` для асинхронного выполнения кода.

**Важно:** 

нужно запомнить, что в документации термин "корутина" используется для двух тесно связанных понятий:

Функция-корутина: функция, определенная с помощью `async def`;  
Объект-корутина: объект, возвращаемый при вызове функции-корутины.

```csharp
async def my_coroutine():
    # функция-корутина


coro = my_coroutine() # объект-корутина
```

**Говоря об awaitable объектах мы всегда имеем ввиду объект-корутину. Также многие встроенные функции asyncio тоже возвращают объект корутину, например `asyncio.sleep(x)` возвращает объект корутины, который мы ожидаем с помощью ключевого слова `await`.** 

В предыдущих уроках мы уже говорили о том, что перед каждым типом awaitable объектов нужно использовать ключевое слово  `await`. Рассмотрим еще раз несколько примеров, так как поведение разных awaitable объектов с ключевым словом `await` немного отличается. 

### Пример 1: использование await c корутиной

```python
import time
import asyncio


async def coro(num, seconds):
    print(f"coro{num} начала свое выполнение")
    await asyncio.sleep(seconds)
    print(f"coro{num} выполнена за {seconds} секунду(ы)")


async def main():
    # Создание объектов корутин путем вызова корутинной функции.
    coro1 = coro(1, 2)
    coro2 = coro(2, 1)
    # Запуск и ожидание выполнения объектов корутин.
    await coro2
    await coro1

start = time.time()
asyncio.run(main())
print(f'Программа выполнена за {time.time()-start:.3f} секунд(ы)')
```

Вывод:

```scss
coro2 начала свое выполнение
coro2 выполнена за 1 секунду(ы)
coro1 начала свое выполнение
coro1 выполнена за 2 секунду(ы)
Программа выполнена за 3.011 секунд(ы)
```

Обратите внимание на то, что хотя порядок создания корутин сначала `coro1,` затем `coro2`, порядок выполнения следует порядку их вызова через `await`. Это связано с тем, что выполнение каждой корутины начинается только тогда, когда мы явно запускаем корутину через `await coro`.

### Пример 2: использование await c объектом `Task`

```python
import asyncio
import time


async def coro(num, seconds):
    print(f"Задача{num} начала свое выполнение")
    await asyncio.sleep(seconds)
    print(f"Задача{num} выполнена за {seconds} секунду(ы)")


async def main():
    # Создание задач из корутины.
    task1 = asyncio.create_task(coro(1, 2))
    task2 = asyncio.create_task(coro(2, 1))
    # Запуск и ожидание выполнения задач.
    await task2
    await task1

start = time.time()
asyncio.run(main())
print(f'Программа выполнена за {time.time()-start:.3f} секунд(ы)')
```

Вывод:

```scss
Задача1 начала свое выполнение
Задача2 начала свое выполнение
Задача2 выполнена за 1 секунду(ы)
Задача1 выполнена за 2 секунду(ы)
Программа выполнена за 2.011 секунд(ы)
```

Обратите внимание, что теперь порядок вывода другой. Задачи начинают выполняться в порядке создания, и их выполнение происходит асинхронно. Общее время выполнения немного превышает время выполнения самой "долгой" задачи. Это связано с тем, что задача при создании добавляется в цикл событий и начинает выполнение при переключении контекста. То есть обе созданные задачи начнут выполнение при первом `await`.
