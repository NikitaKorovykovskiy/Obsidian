Главные мысли:
- Это родительский класс Task - задачи
- Возможность самим устанавливать результат выполнения, мне придумалось так, что могут быть разные условия и по этим условиям надо возвращать разный резльтат. И чтобы не делать много задач, то запустить одну и в условии задавать разный set_result()[[#Установка результата для объектов `Future`. Метод `set_result()`]]
- Можно ожидать выполнение 1 задачи и использовать ее результат во второй задаче[[#Использование результатов выполнения корутин.]]


Помимо класса `Task`, в asyncio есть еще один класс, который является родительским для `Task` - это `Future`. Начиная с версии 3.7 прямое использование задач (`Task`) предпочтительно в большинстве случаев. Однако внутри `asyncio` используются оба класса, так что немного остановимся и на классе `Future`. 

Объекты `Task` и `Future` представляют результат асинхронной операции, которая еще не завершена, но уже ожидается.


### Создание объекта `Future`:

Создавая объект `Task` в прошлом уроке, мы связывали его с определенной корутиной([[6. Корутины]]). 


Создать объект `Future` можно таким способом: 

```ini
future = asyncio.Future() 
```

Создавая объект `Future` таким образом - мы создаем "пустой" объект, не связанный ни с какой корутиной. Чуть ниже попробуем объяснить зачем это нужно и почему иногда нужны именно `Future`, а не объекты `Task`.


### Метод `result()` для объектов `Future/Task`

Важное преимущество объектов `Future/Task` - возможность получения результата выполнения корутины после завершения задачи. Мы ранее говорили, что корутина, как и обычная функция, может принимать аргументы и возвращать результаты. Когда мы оборачиваем корутину в задачу, результат выполнения корутины мы можем получить через метод `result()`.

```python
import asyncio

async def example_task():
    return "Задача выполнена"


async def main():
    task = asyncio.create_task(example_task())  # создание задачи из корутины example_task()
    await task  # запуск задачи и ожидание выполнения
    result = task.result()  # сохранение результата в переменную result
    print(result)

asyncio.run(main())
```

### Установка результата для объектов `Future`. Метод `set_result()`

Одно из отличий `Future` от `Task` - это возможность задавать результат для объекта `Future` через метод `set_result()`. Данный метод может быть полезен при отладке программы.

```python
import asyncio


async def simulate_long_running_task(name, delay, future: asyncio.Future):
    print(f"Задача '{name}' началась, будет выполнена за {delay} секунд.")
    await asyncio.sleep(delay)
    result = f"Результат задачи '{name}'"
    print(f"Задача '{name}' завершена.")
    future.set_result(result)  # Устанавливаем результат для Future объекта


async def main():
    # Создаем объект Future
    future = asyncio.Future()

    # Запускаем корутину, передаем Future объект в функцию
    await simulate_long_running_task("Задача1", 3, future)

    # Получаем результат выполнения задачи
    result = future.result()
    print(f"Результат Future: {result}")


asyncio.run(main())
```



### Использование результатов выполнения корутин.

Во многих случаях результат выполнения одной корутины нужно использовать в качестве аргумента для выполнения второй корутины. В этом случае нужно выполнять корутины последовательно, дожидаясь выполнения первой корутины. А полученный результат передавать в качестве аргумента для второй корутины. 

Ниже приведен пример такой ситуации. Так как данный урок посвящен объектам `Future`, мы не будем возвращать результат корутины стандартным способом, а для примера воспользуемся методом `set_result()` объектов `Future`. 

```python
import asyncio


async def do_some_work_1(x, future: asyncio.Future):
    print(f"Выполняется работа 1: {x}")
    await asyncio.sleep(x)
    future.set_result(x * 2)


async def do_some_work_2(x, future: asyncio.Future):
    print(f"Выполняется работа 2: {x}")
    await asyncio.sleep(x)
    future.set_result(x + 2)


async def main():
    # Создаем объекты Future для каждой задачи
    future_1 = asyncio.Future()
    future_2 = asyncio.Future()

    # Запускаем первую задачу и передаем ей Future
    asyncio.create_task(do_some_work_1(2, future_1))

    # Дожидаемся завершения первой задачи
    await future_1
    result_1 = future_1.result()

    # Запускаем вторую задачу, передавая результат первой и объект Future
    asyncio.create_task(do_some_work_2(result_1, future_2))

    # Дожидаемся завершения второй задачи
    await future_2
    result_2 = future_2.result()

    print(f"Результат future_1: {result_1}")  # Выводим результат первой задачи
    print(f"Результат future_2: {result_2}")  # Выводим результат второй задачи


asyncio.run(main())
```