Основные мысли:
- asyncio только оно не дает делать асинхронные штуки, нужна именно await, тк она останавливает работу этой корутины (задачи) и передает управление в цикл событий
- await возвращает результат(п. 5)
- Можно использовать результат одной функции как аргумент другой
### Правила и особенности использования `await`.

**1. `await` - это ключевое слово, которое используется для переключения между awaitable объектами.** Основная задача асинхронного программирования - конкурентное выполнение задач. Это возможно благодаря `await`. Когда интерпретатор Python встречает ключевое слово `await`, он приостанавливает выполнение текущей функции и передает управление обратно в цикл событий.

**2. `await` нельзя использовать с не awaitable объектами.** При попытке использовать `await` с объектами, не поддерживающими ожидание, т.е. не с awaiable объектами, мы получим ошибку TypeError.

```python
# НЕЛЬЗЯ
import asyncio

async def main():
    await None  # или await "Hello, World!" и др. не awaitable объекты

asyncio.run(main())  # ошибка TypeError!
```


**3.** **await** нельзя использовать вне корутин.

```python
# НЕЛЬЗЯ
import asyncio

def main():
    await asyncio.sleep(1)

asyncio.run(main())  # ошибка SyntaxError!
```

**4. `await` блокирует выполнение корутины.** Несмотря на то, что именно `await` дает возможность конкурентного выполнения задач, ожидание является блокирующей операцией внутри текущей корутины. При этом другие корутины могут продолжать свою работу.

**5. **`await`** возвращает результат.** Так как await блокирует выполнение корутины и дожидается выполнения операции - он же возвращает результат. Ранее мы использовали для получения результата функцию `result()`, но можем использовать и `await`.

```python
import asyncio

async def my_coroutine():
    await asyncio.sleep(1)
    return "Задача завершена"

async def main():
    result = await my_coroutine()  # сохраняем в переменную результат выполнения my_coroutine() 
    print(result)


asyncio.run(main())
```

**6. Корутина должна содержать `await` , чтобы реализовать преимущества `asyncio`.** Мы можем написать корутину, в которой не будет ключевого слова `await` и ошибок не будет. Но при такой реализации выполняемая корутина не сможет передать управление, следовательно асинхронная функция отработает как обычная синхронная функция. Выполнение других задач начнется после полного завершения корутины. Для демонстрации такого случая рассмотрим пример, в котором вместо поддерживающей ожидание функции `asyncio.sleep()` будет использована синхронная `time.sleep()`.


### Осторожность при использовании `await`:

При использовании `await` необходимо быть осторожным, чтобы избежать неожиданных ошибок. 

1. **Ошибки выполнения**: если асинхронная функция, которую вы ожидаете, выбрасывает исключение, `await` также выбросит это исключение. Как обрабатывать подобные исключения, мы будем говорить в следующих темах.
    
2. **Задержки в выполнении кода**: следует помнить, что использование `await` может привести к задержкам, так как он останавливает выполнение текущей корутины, пока не будет получен результат выполнения указанной асинхронной операции.
3. 