Задачи нужны для конкурентного выполнения задач

### Создание и запуск задач

Для создания задачи используется функция `asyncio.create_task()`. Возьмем пример из предыдущего урока и попробуем выполнить корутину `example_coroutine()`, обернув ее в задачу. 

```python
import asyncio


async def example_coroutine():
    await asyncio.sleep(1) 
    print("Hello from coroutine!")

async def main():
    task = asyncio.create_task(example_coroutine())  # создаем задачу из корутины example_coroutine()
    await task # ждем выполнения задачи

asyncio.run(main())
```

### Выполнение нескольких задач конкурентно. Метод `asyncio.gather()`.

Как только задача создана из корутины, она становится независимой. Это означает, что выполнение задачи больше не связано напрямую с корутиной, которая её породила. Задача будет запланирована и управляема циклом событий , который определяет, когда задача получит возможность, чтобы начать свое выполнение. Цикл событий предоставляет такую возможность всем задачам, запланированным к запуску, при первой же смене контекста (`await`), и запускает её (задачу) асинхронно.

Попробуем создать в нашем примере 10 задач и запустить их конкурентно.  Для создания задач используем метод `asyncio.create_task()`, а для конкурентного запуска метод `asyncio.gather()`.

```python
import asyncio


async def example_coroutine():
    await asyncio.sleep(1)
    print("Hello from coroutine!")

async def main():
    tasks = []
    for _ in range(10):
        task = asyncio.create_task(example_coroutine())  # создаем 10 задач
        tasks.append(task)  # добавляем все задачи в список tasks
    await asyncio.gather(*tasks)  # запускаем все задачи из списка tasks

asyncio.run(main())
```

**Важно!** Сохраняйте ссылку на результат функции `asyncio.create_task()`, чтобы задача не исчезла в процессе выполнения. Цикл событий сохраняет только слабые ссылки на задачи (_тип ссылки в Python, которая не препятствует удалению объекта, на который она ссылается_). Задача, на которую больше нигде нет ссылок, кроме слабых ссылок цикла событий, может быть удалена сборщиком мусора в любое время, даже до того, как она будет выполнена. Для надежных фоновых задач типа "запустил и забыл" нужно собрать их в коллекцию (_множество, список или кортеж_), как мы это делали в примерах выше.

==Ниже продемонстрирован плохой пример== — создание задачи без сохранения ссылок, т. е. без создания переменных или списка задач. Код ниже хоть и запустится, но в других ситуациях задача может быть удалена сборщиком мусора.

```python
import asyncio

async def my_task():
    print(f"{'-' * 10}\nRunning my task")
    await asyncio.sleep(1)
    print(f"Task complete\n{'-' * 10}")

async def main():
    # Создаем задачу без сохранения ссылки на нее
    asyncio.create_task(my_task())
    # Здесь произойдет запуск задачи, однако стоит помнить,
    # что эта задача может быть удалена сборщиком мусора в любой момент.
    await asyncio.sleep(2)

asyncio.run(main())
```

В этом конкретном случае задача будет выполнена, но такое поведение не гарантировано, в силу особенностей работы сборщика мусора Python.