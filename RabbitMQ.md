RabbitMQ позволяет взаимодействовать различным программам при помощи протокола AMQP. RabbitMQ является отличным решением для построения SOA (сервис-ориентированной архитектуры) и распределением отложенных ресурсоемких задач.  
  
Под катом перевод [первого](http://www.rabbitmq.com/tutorials/tutorial-one-python.html) из шести уроков официального сайта. Примеры на python, но его знание вовсе не обязательно. Аналогичные примеру программы можно воспроизвести практически на любом популярном ЯП. _[так выглядят комментарии переводчика, т.е. меня]_  
#### Вступление

RabbitMQ ‒ это брокер сообщений. Его основная цель ‒ принимать и отдавать сообщения. Его можно представлять себе, как почтовое отделение: когда Вы бросаете письмо в ящик, Вы можете быть уверены, что рано или поздно почтальон доставит его адресату _[видимо, автор ни разу не имел дела с Почтой России]_. В этой аналогии RabbitMQ является одновременно и почтовым ящиком, и почтовым отделением, и почтальоном.  
  
Наибольшее отличие RabbitMQ от почтового отделения в том, что он не имеет дела с бумажными конвертами ‒ RabbitMQ принимает, хранит и отдает бинарные данные ‒ сообщения.  
  
В RabbitMQ, а также обмене сообщениями в целом, используется следующая терминология:  
  
- **Producer** (поставщик) ‒ программа, отправляющая сообщения. В схемах он будет представлен кругом с буквой «P»:  
    ![](https://habrastorage.org/r/w1560/storage2/546/6c4/d2e/5466c4d2e902e8cd0db71c7ba06e3e95.png)  
    
- **Queue** (очередь) ‒ имя «почтового ящика». Она существует внутри RabbitMQ. Хотя сообщения проходят через RabbitMQ и приложения, хранятся они только в очередях. Очередь не имеет ограничений на количество сообщений, она может принять сколь угодно большое их количество ‒ можно считать ее бесконечным буфером. Любое количество поставщиков может отправлять сообщения в одну очередь, также любое количество подписчиков может получать сообщения из одной очереди. В схемах очередь будет обозначена стеком и подписана именем:  
      
    ![](https://habrastorage.org/r/w1560/storage2/64c/bc5/37e/64cbc537e28a8441119f1ce8f13421e1.png)  
    
- **Consumer** (подписчик) ‒ программа, принимающая сообщения. Обычно подписчик находится в состоянии ожидания сообщений. В схемах он будет представлен кругом с буквой «C»:  
      
    ![](https://habrastorage.org/r/w1560/storage2/8ce/aed/6d5/8ceaed6d537b1951a5aee11b3dbcc9b7.png)  
    


Поставщик, подписчик и брокер не обязаны находиться на одной физической машине, обычно они находятся на разных.

### Кратко про AMQP

> AMQP (Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Основная идея состоит в том, что отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет маршрутизацию, возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений.

Протокол `AMQP` вводит три понятия:
![rabbitmq_1](https://habrastorage.org/r/w1560/getpro/habr/post_images/6f4/7e9/2a8/6f47e92a8d4ebca0e828abd0970596e9.jpg)

- ==`exchange`== (обменник или точка обмена) — в неё отправляются сообщения. Обменник **распределяет сообщение** в одну или несколько очередей. Он **маршрутизирует сообщения в очередь** на основе созданных связей (`binding`) между ним и очередью
- ==`queue`== (очередь) — структура данных на диске или в оперативной памяти, которая **хранит ссылки на сообщения и отдает копии сообщений `consumers`** (потребителям). Одна очередь может использоваться несколькими потребителями
- ==`binding`== (привязка) — правило, которое **сообщает точке обмена в какую из очередей эти сообщения должны попадать**. Обменник и очередь могут быть связаны несколькими привязками
### Кратко про RabbitMQ

[RabbitMQ](https://www.rabbitmq.com/) – это брокер сообщений с открытым исходным кодом. Он маршрутизирует собщения по всем базовым принципам протокола [AMQP](https://ru.wikipedia.org/wiki/AMQP) описанным в [спецификации](http://www.amqp.org/resources/download). Отправитель передает сообщение брокеру а тот доставляет его получателю. `RabbitMQ` реализует и дополняет протокол `AMQP`.

Основная идея модели обмена сообщениями в `RabbitMQ` заключается в том, что `producer` (издатель) не отправляет сообщения непосредственно в очередь. На самом деле и довольно часто издатель даже не знает, будет ли сообщение вообще доставлено в какую-либо очередь.

Вместо этого издатель может отправлять сообщения только на обмен. С одной стороны, обмен получает сообщения от издателей, а с другой — отправляет их в очереди. Обмен должен точно знать, что делать с полученным сообщением. Должно ли оно быть добавлено в определенную очередь? Должно ли оно быть добавлено в несколько очередей? Или сообщение нужно игнорировать.
![Image from: http://bit.ly/2U3PyJz](https://habrastorage.org/r/w1560/getpro/habr/post_images/1e8/006/fbb/1e8006fbb2212da5d284f246fa0f64bc.png)
Кратко работу `RabbitMQ` можно описать следующим образом:

1. Издатель отправляет сообщение определенному обменнику
2. Обменник, получив сообщение, маршрутизирует его в одну или несколько очередей в соответствии с правилами привязки между ним и очередью
3. Очередь хранит ссылку на это сообщение. Само сообщение хранится в оперативной памяти или на диске
4. Как только потребитель готов получить сообщение из очереди, сервер создает копию сообщения по ссылке и отправляет
5. Потребитель получает сообщение и отправляет брокеру подтверждение
6. Брокер, получив подтверждение, удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти и с диска

### Разбираемся с Exchanges
`Exchange` — обменник или точка обмена. В него отправляются сообщения. `Exchange` **распределяет сообщение** в одну или несколько очередей. Он **маршрутизирует сообщения в очередь** на основе созданных связей (`bindings`) между ним и очередью.

#### _Direct Exchange_
`Direct exchange` — используется, когда нужно **доставить сообщение в определенные очереди**. Сообщение публикуется в обменник с определенным **ключом маршрутизации** и попадает во все очереди, которые связаны с этим обменником аналогичным ключом маршрутизации. **Ключ маршрутизации** – это атрибут сообщения, добавленный в заголовок сообщения паблишера. Ключ маршрутизации можно рассматривать как «адрес», который использует exchange, чтобы решить, как маршрутизировать сообщение. Сообщение отправляется в очередь (очереди), чей ключ точно соответствует ключу маршрутизации сообщения.. Поиск соответствия происходит при помощи **проверки строк на эквивалентность**.

Графическое представление потока сообщений:
![rabbitmq_4](https://habrastorage.org/r/w1560/webt/zg/3h/lj/zg3hljyzecuxqawkeamutasd2em.jpeg)

В `rabbitmq` существует понятие **обменник по умолчанию**. Это `direct exchange` без имени. Если применяется обменник по умолчанию, то сообщение будет маршрутизироваться в очередь с именем равным **ключу маршрутизации сообщения**.

#### _Topic Exchange_
`Topic exchange` – аналогично `direct exchange` дает возможность осуществления выборочной маршрутизации путем сравнения ключа маршрутизации. Но, в данном случае, ключ задается **по шаблону**. При создании шаблона используются `0` или более слов (буквы `AZ` и `az` и цифры `0-9`), разделенных точкой, а также символы `*` и `#`.
- `*` — может быть заменен на ровно `1` слово
- `#` — может быть заменен на `0` или более слов

Графическое представление потока сообщений:
![rabbitmq_6](https://habrastorage.org/r/w1560/webt/p8/9w/bi/p89wbipkobdmt_85yvyib2kwuru.jpeg)


#### _Fanout Exchange_
`Fanout exchange` – **все сообщения доставляются во все очереди** даже если в сообщении задан ключ маршрутизации.

Особенности:
- `RabbitMQ` **не работает с ключами маршрутизации и шаблонами** что положительно влияет на производительность. Это самый быстрый `exchange`;
- все потребители должны иметь возможность обрабатывать все сообщения;

Графическое представление потока сообщений:
![rabbitmq_5](https://habrastorage.org/r/w1560/webt/6e/ij/bo/6eijbobnabcyoopzbyec_axnjoe.jpeg)

#### _Headers Exchange_
`Headers exchange` — направляет сообщения в связанные очереди на основе сравнения пар (ключ, значение) свойства `headers` привязки и аналогичного свойства сообщения. `headers` представляет собой `Dictionary<ключ, значение>`.
Графическое представление потока сообщений:
![rabbitmq_7_a](https://habrastorage.org/r/w1560/webt/nr/fi/4f/nrfi4fzr8uu1qhwrwe9avj5sryk.jpeg)

#### _Комбинирование обменников (E2E)_
Поведение всех обменников можно комбинировать при помощи связи **Exchange-to-Exchange** (комбинирование обменников не входит в спецификацию `AMQP`. Это расширение протокола со стороны `RabbitMQ`).

Графическое представление потока сообщений:
![rabbitmq_8](https://habrastorage.org/r/w1560/webt/cx/bf/yt/cxbfyt67w9egigkoh6ov_k9j7dg.jpeg)

За счет `E2E` мы можем найти правильную масштабируемую конфигурацию, которая отвечает как текущим, так и растущим требованиям.