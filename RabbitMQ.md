RabbitMQ позволяет взаимодействовать различным программам при помощи протокола AMQP. RabbitMQ является отличным решением для построения SOA (сервис-ориентированной архитектуры) и распределением отложенных ресурсоемких задач.  
  
Под катом перевод [первого](http://www.rabbitmq.com/tutorials/tutorial-one-python.html) из шести уроков официального сайта. Примеры на python, но его знание вовсе не обязательно. Аналогичные примеру программы можно воспроизвести практически на любом популярном ЯП. _[так выглядят комментарии переводчика, т.е. меня]_  
#### Вступление

RabbitMQ ‒ это брокер сообщений. Его основная цель ‒ принимать и отдавать сообщения. Его можно представлять себе, как почтовое отделение: когда Вы бросаете письмо в ящик, Вы можете быть уверены, что рано или поздно почтальон доставит его адресату _[видимо, автор ни разу не имел дела с Почтой России]_. В этой аналогии RabbitMQ является одновременно и почтовым ящиком, и почтовым отделением, и почтальоном.  
  
Наибольшее отличие RabbitMQ от почтового отделения в том, что он не имеет дела с бумажными конвертами ‒ RabbitMQ принимает, хранит и отдает бинарные данные ‒ сообщения.  
  
В RabbitMQ, а также обмене сообщениями в целом, используется следующая терминология:  
  
- **Producer** (поставщик) ‒ программа, отправляющая сообщения. В схемах он будет представлен кругом с буквой «P»:  
    ![](https://habrastorage.org/r/w1560/storage2/546/6c4/d2e/5466c4d2e902e8cd0db71c7ba06e3e95.png)  
    
- **Queue** (очередь) ‒ имя «почтового ящика». Она существует внутри RabbitMQ. Хотя сообщения проходят через RabbitMQ и приложения, хранятся они только в очередях. Очередь не имеет ограничений на количество сообщений, она может принять сколь угодно большое их количество ‒ можно считать ее бесконечным буфером. Любое количество поставщиков может отправлять сообщения в одну очередь, также любое количество подписчиков может получать сообщения из одной очереди. В схемах очередь будет обозначена стеком и подписана именем:  
      
    ![](https://habrastorage.org/r/w1560/storage2/64c/bc5/37e/64cbc537e28a8441119f1ce8f13421e1.png)  
    
- **Consumer** (подписчик) ‒ программа, принимающая сообщения. Обычно подписчик находится в состоянии ожидания сообщений. В схемах он будет представлен кругом с буквой «C»:  
      
    ![](https://habrastorage.org/r/w1560/storage2/8ce/aed/6d5/8ceaed6d537b1951a5aee11b3dbcc9b7.png)  
    


Поставщик, подписчик и брокер не обязаны находиться на одной физической машине, обычно они находятся на разных.

### Кратко про AMQP

> AMQP (Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Основная идея состоит в том, что отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет маршрутизацию, возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений.

Протокол `AMQP` вводит три понятия:

![rabbitmq_1](https://habrastorage.org/r/w1560/getpro/habr/post_images/6f4/7e9/2a8/6f47e92a8d4ebca0e828abd0970596e9.jpg)

  

- `exchange` (обменник или точка обмена) — в неё отправляются сообщения. Обменник **распределяет сообщение** в одну или несколько очередей. Он **маршрутизирует сообщения в очередь** на основе созданных связей (`binding`) между ним и очередью
- `queue` (очередь) — структура данных на диске или в оперативной памяти, которая **хранит ссылки на сообщения и отдает копии сообщений `consumers`** (потребителям). Одна очередь может использоваться несколькими потребителями
- `binding` (привязка) — правило, которое **сообщает точке обмена в какую из очередей эти сообщения должны попадать**. Обменник и очередь могут быть связаны несколькими привязками

### Кратко про RabbitMQ

[RabbitMQ](https://www.rabbitmq.com/) – это брокер сообщений с открытым исходным кодом. Он маршрутизирует собщения по всем базовым принципам протокола [AMQP](https://ru.wikipedia.org/wiki/AMQP) описанным в [спецификации](http://www.amqp.org/resources/download). Отправитель передает сообщение брокеру а тот доставляет его получателю. `RabbitMQ` реализует и дополняет протокол `AMQP`.

Основная идея модели обмена сообщениями в `RabbitMQ` заключается в том, что `producer` (издатель) не отправляет сообщения непосредственно в очередь. На самом деле и довольно часто издатель даже не знает, будет ли сообщение вообще доставлено в какую-либо очередь.

Вместо этого издатель может отправлять сообщения только на обмен. С одной стороны, обмен получает сообщения от издателей, а с другой — отправляет их в очереди. Обмен должен точно знать, что делать с полученным сообщением. Должно ли оно быть добавлено в определенную очередь? Должно ли оно быть добавлено в несколько очередей? Или сообщение нужно игнорировать.
![Image from: http://bit.ly/2U3PyJz](https://habrastorage.org/r/w1560/getpro/habr/post_images/1e8/006/fbb/1e8006fbb2212da5d284f246fa0f64bc.png)
Кратко работу `RabbitMQ` можно описать следующим образом:

1. Издатель отправляет сообщение определенному обменнику
2. Обменник, получив сообщение, маршрутизирует его в одну или несколько очередей в соответствии с правилами привязки между ним и очередью
3. Очередь хранит ссылку на это сообщение. Само сообщение хранится в оперативной памяти или на диске
4. Как только потребитель готов получить сообщение из очереди, сервер создает копию сообщения по ссылке и отправляет
5. Потребитель получает сообщение и отправляет брокеру подтверждение
6. Брокер, получив подтверждение, удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти и с диска