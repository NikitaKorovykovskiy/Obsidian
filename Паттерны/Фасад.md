Создает уникальный интерфес с условно 1 методом, который в себе собирает несколько разных классов - функций и выполняет их в рамках одной своей функции.
Что то похожее на фасад я применил в сервисе отправки сообщений на АГ

Без фасада код выглядит так
```python
# services/email_service.py

class EmailService:
    def send_email(self, to, subject, message):
        # код для отправки email
        pass

# services/payment_service.py

class PaymentService:
    def process_payment(self, amount, account):
        # код для обработки платежа
        pass

# services/sms_service.py

class SMSService:
    def send_sms(self, to, message):
        # код для отправки sms
        pass

# main.py

from services.email_service import EmailService
from services.payment_service import PaymentService
from services.sms_service import SMSService

email_service = EmailService()
payment_service = PaymentService()
sms_service = SMSService()

# Здесь в `handle_order` приходится напрямую работать с каждым сервисом, что создает зависимости и усложняет поддержку. По сути это похоже на фасад, но проблема в том что это бизнес логика усложнена.

def handle_order():
    email_service.send_email('user@example.com', 'Order Confirmation', 'Thank you for your order')
    payment_service.process_payment(100, 'user_account')
    sms_service.send_sms('+123456789', 'Your order has been confirmed')

```

Реализация с фасадом
```python

```
