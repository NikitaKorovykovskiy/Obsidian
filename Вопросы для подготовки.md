##### Плюсы и минусы клиент-серверной архитектуры
+
1. клиент-серверная архитектура дает нам определённую масштабируемость: есть сервер, есть единая точка обработки запросов. При необходимости выдерживать большую нагрузку мы можем поставить несколько серверов. Также к нему можно подключать достаточно большое количество клиентов (сколько сможет выдержать). Таким образом, **клиент-серверная архитектура позволяет добиться масштабируемости.**  
  
2. REST даёт **определённую простоту поддержки**. Если мы хотим изменить логику обработки информации на сервере, то выполним эти изменения на сервере. В данном случае мы можем и не менять каждого клиента, как если бы они были абсолютно равноценной сетью.  
-
1. В случае с клиент-серверной архитектурой мы понимаем, что у нас есть единая точка отказа в виде сервера. Если отказал сервер и у нас нет дополнительных инстансов, то для нас это будет означать неработоспособность системы.  
  
2. Также потенциально может увеличиться нагрузка, поскольку часть логики мы вынесли с клиента на сервер. Клиент будет совершать меньше каких-либо действий самостоятельно, соответственно, у нас возрастёт количество запросов между клиентом и сервером.
##### Зачем нужны модели ресурсов?
В рамках `django-import-export` модель ресурса - это специальный класс, который определяет, как данные между Django-моделью и файлом данных будут импортироваться и экспортироваться.

Модель ресурса в `django-import-export` служит для:

1. **Определения полей для импорта и экспорта:** Модель ресурса определяет, какие поля из Django-модели будут включены в процесс импорта и экспорта. Это может включать в себя спецификацию типов данных, форматов и других параметров.
    
2. **Управления процессом преобразования данных:** Вы можете определить методы преобразования данных в модели ресурса. Например, вы можете предоставить метод для преобразования строкового представления даты в объект `datetime`.
    
3. **Определения правил для валидации данных:** Модель ресурса может предоставлять правила для валидации данных при импорте. Это может включать в себя проверку формата данных, наличие обязательных полей и другие проверки.
Пример простой модели ресурса с использованием `django-import-export`:
```python
from import_export import resources, fields 
from .models import YourModel  

class YourModelResource(resources.ModelResource):
	class Meta:
		model = YourModel
		fields = ('field1', 'field2', 'field3')`
```

Здесь `YourModelResource` - это модель ресурса для модели `YourModel`, и в ней указываются поля, которые будут включены в процесс импорта и экспорта.

Использование моделей ресурсов делает процесс импорта и экспорта более гибким и позволяет вам настроить это поведение в соответствии с вашими требованиями.
##### Как в Django реализована защита от CSRF атак

Новая защита требует от вас теперь вручную добавлять `{% csrf_token %}` во все ваши формы, которые вы хотите защитить. Или в заголовки при выполнении AJAX запросов.

##### Как написать задачу, как поставить задачу в очередь, можно ли задать задержку перед исполнением в Celery
1. Написать задачу можно либо:
	1.  в виде функции с декоратором .task
	```python
	@celery_app.task(name='officialsnotification.tasks.worker')
	def worker():
```
	1. в виде класса

	```python
	from celery import Celery, Task import time  


	# Создание экземпляра 
	Celery app = Celery('tasks', broker='pyamqp://guest@localhost//')  
	# Определение класса задачи 
	class AddTask(Task):     
		name = 'tasks.add'      
		def run(self, x, y):         
			time.sleep(5)  # Представим, что это занимает некоторое время         return x + y  
	
	# Регистрация класса задачи 
	app.register_task(AddTask())
```


2. Поставить задачу в очередь
	1. В качестве альтернативы можно использовать сопоставление шаблонов glob или даже регулярные выражения для сопоставления всех задач в пространстве имен `feed.tasks`
		```python
		app.conf.task_routes = {'feed.tasks.*': {'queue': 'feeds'}}
		```
		Если порядок соответствия шаблонов важен, то вместо этого следует указать маршрутизатор в формате _items_:
		```python
		task_routes = ([
		    ('feed.tasks.*', {'queue': 'feeds'}),
		    ('web.tasks.*', {'queue': 'web'}),
		    (re.compile(r'(video|image)\.tasks\..*'), {'queue': 'media'}),
		],)
		```
		Или указывать очередь прямо в момент создания задачки
		```python
		@celery_app.task(name='gateway.tasks.covid_sms_send', queue='sms-channel')
		```
		
		После установки маршрутизатора вы можете запустить сервер z для обработки только очереди фидов следующим образом
		```python
		celery -A proj worker -Q feeds
```
	2. ==**`delay`**:==
    
    - `delay` - это метод, который добавляет задачу в очередь с использованием декоратора `@task`.
    - Он предоставляет простой способ постановки задачи в очередь, обеспечивая асинхронное выполнение функции.
    - Применяется, когда у вас нет необходимости в сложной конфигурации задачи.
    
	3. ==**`apply_async`**:==
    
    - `apply_async` - это метод, который дает вам более гибкий контроль над параметрами задачи.
    - Вы можете настроить различные параметры, такие как аргументы, ключевые слова, задержка перед выполнением задачи и другие параметры.
    - Часто используется, когда вам нужно более тонкое управление параметрами задачи.
3.  Задержка перед применением
```python
from celery import Celery  
app = Celery('tasks', broker='pyamqp://guest@localhost//')  
@app.task
	def add(x, y):     
		return x + y  result = add.apply_async(args=[4, 4], countdown=10) <= Тут
```
В приведенном выше примере `args=[4, 4]` указывает аргументы задачи, а ==`countdown=10`== устанавливает задержку в 10 секунд перед выполнением задачи.
##### Какую роль выполняет объект scope?
В Django Channels объект `scope` представляет собой словарь с информацией о текущем запросе WebSocket. В контексте Django Channels, когда вы работаете с WebSocket-соединениями, `scope` является аналогом объекта `request` в обычных HTTP-запросах. Однако, `scope` содержит информацию, специфичную для WebSocket.

Роль объекта `scope`:

1. **Информация о соединении:**
    
    - `scope` содержит информацию о WebSocket-соединении, такую как его уникальный идентификатор (`'websocket.connecting'`) и другие параметры, связанные с соединением.
2. **Данные запроса:**
    
    - В `scope` содержатся данные, связанные с текущим запросом WebSocket. Это может включать в себя параметры запроса, такие как URL путь (`'path'`), параметры пути (`'kwargs'`), параметры запроса (`'query_string'`), хост и другие.
3. **Аутентификация и авторизация:**
    
    - Вы можете использовать `scope` для выполнения аутентификации и авторизации WebSocket-соединения, подобно тому, как вы делаете это с обычными HTTP-запросами в Django.
4. **Контекст обработчика:**
    
    - Обработчики Django Channels получают объект `scope` как часть своего контекста. Это позволяет обработчикам получать доступ к информации о текущем соединении и запросе WebSocket.

	Пример использования `scope` в Django Channels:
	```python
	async def websocket_connect(message):     
	# Извлекаем объект scope     
	scope = message['scope']      
	# Извлекаем информацию о соединении     
	connection_id = scope['websocket.connecting']['connection_id']      
	# Извлекаем данные запроса     
	path = scope['path']     
	query_string = scope['query_string']      
	# Ваш код обработки WebSocket-соединения     # ...      
	# Пример отправки сообщения обратно клиенту     
	await message.reply_channel.send({
		'type': 'websocket.accept',
	})
	```
	Объект `scope` предоставляет информацию, необходимую для обработки WebSocket-соединений в Django Channels и обеспечивает доступ к данным запроса и контексту соединения.
##### Как устроена реликация данных в топиках?
Как работает репликация? Создавая топик в Kafka, мы указываем для него коэффициент репликации — replication-factor. Допустим, у нас два брокера и мы устанавливаем replication-factor 2. Теперь Kafka попытается всегда создавать бэкап, или реплику, для каждой партиции в топике. Kafka распределяет партиции примерно так же, как HDFS распределяет блоки данных по нодам.  
  
Допустим, для топика freblogg мы установили коэффициент репликации 2. Мы получим примерно такое распределение партиций:  
  

![](https://static.tildacdn.com/tild3130-3832-4563-b964-346430376165/tmhocwn0giruofl_xyyx.png)

  
  
Даже если реплицированная партиция находится в другом брокере, Kafka не разрешает ее читать, потому что в каждом наборе партиций есть LEADER, то есть лидер, и FOLLOWERS — ведомые, которые остаются в резерве. Ведомые периодически синхронизируются с лидером и ждут своего звездного часа. Когда лидер выйдет из строя, один из in-sync ведомых будет выбран новым лидером, и вы будете получать данные из этой партиции.  
  
Лидер и ведомый одной партиции всегда находятся в разных брокерах. Думаю, не нужно объяснять, почему.

Итог:
- Реплицированные партиции существуют пассивно. Вы обращаетесь к ним, только если сломался лидер.

##### Варианты настройки роутинга в Exchange
[[RabbitMQ#Разбираемся с Exchanges]]
