##### Плюсы и минусы клиент-серверной архитектуры
+
1. клиент-серверная архитектура дает нам определённую масштабируемость: есть сервер, есть единая точка обработки запросов. При необходимости выдерживать большую нагрузку мы можем поставить несколько серверов. Также к нему можно подключать достаточно большое количество клиентов (сколько сможет выдержать). Таким образом, **клиент-серверная архитектура позволяет добиться масштабируемости.**  
  
2. REST даёт **определённую простоту поддержки**. Если мы хотим изменить логику обработки информации на сервере, то выполним эти изменения на сервере. В данном случае мы можем и не менять каждого клиента, как если бы они были абсолютно равноценной сетью.  
-
1. В случае с клиент-серверной архитектурой мы понимаем, что у нас есть единая точка отказа в виде сервера. Если отказал сервер и у нас нет дополнительных инстансов, то для нас это будет означать неработоспособность системы.  
  
2. Также потенциально может увеличиться нагрузка, поскольку часть логики мы вынесли с клиента на сервер. Клиент будет совершать меньше каких-либо действий самостоятельно, соответственно, у нас возрастёт количество запросов между клиентом и сервером.
##### Зачем нужны модели ресурсов?
В рамках `django-import-export` модель ресурса - это специальный класс, который определяет, как данные между Django-моделью и файлом данных будут импортироваться и экспортироваться.

Модель ресурса в `django-import-export` служит для:

1. **Определения полей для импорта и экспорта:** Модель ресурса определяет, какие поля из Django-модели будут включены в процесс импорта и экспорта. Это может включать в себя спецификацию типов данных, форматов и других параметров.
    
2. **Управления процессом преобразования данных:** Вы можете определить методы преобразования данных в модели ресурса. Например, вы можете предоставить метод для преобразования строкового представления даты в объект `datetime`.
    
3. **Определения правил для валидации данных:** Модель ресурса может предоставлять правила для валидации данных при импорте. Это может включать в себя проверку формата данных, наличие обязательных полей и другие проверки.
Пример простой модели ресурса с использованием `django-import-export`:
```python
from import_export import resources, fields 
from .models import YourModel  

class YourModelResource(resources.ModelResource):
	class Meta:
		model = YourModel
		fields = ('field1', 'field2', 'field3')`
```

Здесь `YourModelResource` - это модель ресурса для модели `YourModel`, и в ней указываются поля, которые будут включены в процесс импорта и экспорта.

Использование моделей ресурсов делает процесс импорта и экспорта более гибким и позволяет вам настроить это поведение в соответствии с вашими требованиями.
##### как в Django реализована защита от CSRF атак

Новая защита требует от вас теперь вручную добавлять `{% csrf_token %}` во все ваши формы, которые вы хотите защитить. Или в заголовки при выполнении AJAX запросов.

##### как написать задачу, как поставить задачу в очередь, можно ли задать задержку перед исполнением

1. Написать задачу можно либо:
	1.  в виде функции с декоратором .task
	```python
	@celery_app.task(name='officialsnotification.tasks.worker')
	def worker():
```
	1. в виде класса

	```python
	from celery import Celery, Task import time  
	# Создание экземпляра 
	Celery app = Celery('tasks', broker='pyamqp://guest@localhost//')  
	# Определение класса задачи 
	class AddTask(Task):     
		name = 'tasks.add'      
		def run(self, x, y):         
			time.sleep(5)  # Представим, что это занимает некоторое время         return x + y  
	
	# Регистрация класса задачи 
	app.register_task(AddTask())
```


2. Поставить задачу в очередь
	1. В качестве альтернативы можно использовать сопоставление шаблонов glob или даже регулярные выражения для сопоставления всех задач в пространстве имен `feed.tasks`
		```python
		app.conf.task_routes = {'feed.tasks.*': {'queue': 'feeds'}}
		```
		Если порядок соответствия шаблонов важен, то вместо этого следует указать маршрутизатор в формате _items_:
		```python
		task_routes = ([
		    ('feed.tasks.*', {'queue': 'feeds'}),
		    ('web.tasks.*', {'queue': 'web'}),
		    (re.compile(r'(video|image)\.tasks\..*'), {'queue': 'media'}),
		],)
		```
		Или указывать очередь прямо в момент создания задачки
		```python
		@celery_app.task(name='gateway.tasks.covid_sms_send', queue='sms-channel')
		```
		
		После установки маршрутизатора вы можете запустить сервер z для обработки только очереди фидов следующим образом
		```python
		celery -A proj worker -Q feeds
```
	2. ==**`delay`**:==
    
    - `delay` - это метод, который добавляет задачу в очередь с использованием декоратора `@task`.
    - Он предоставляет простой способ постановки задачи в очередь, обеспечивая асинхронное выполнение функции.
    - Применяется, когда у вас нет необходимости в сложной конфигурации задачи.
    
	3. ==**`apply_async`**:==
    
    - `apply_async` - это метод, который дает вам более гибкий контроль над параметрами задачи.
    - Вы можете настроить различные параметры, такие как аргументы, ключевые слова, задержка перед выполнением задачи и другие параметры.
    - Часто используется, когда вам нужно более тонкое управление параметрами задачи.

##### какую роль выполняет объект scope?
##### как устроена реликация данных в топиках?
##### варианты настройки роутинга в Exchange