Выражения-генераторы - **выдают элемент по-одному, не загружая в память сразу всю коллекцию**

#### Классификация и особенности
- **выражение-генератор** (generator expression) — выражение в круглых скобках которое выдает создает на каждой итерации новый элемент по правилам.
- **генератор коллекции** — обобщенное название для генератора списка (list comprehension), генератора словаря (dictionary comprehension) и генератора множества (set comprehension)

![image](https://habrastorage.org/r/w1560/files/688/052/4d1/6880524d12ff4f689c0a84d1302c5715.png)


### Ветвление выражения
**Обратите внимание:** Мы можем использовать (начиная с Python 2.5) в выражении конструкцию **if-else для ветвления финального выражения**.  
  
В таком случае:  
  
- Условия ветвления пишутся не после, а перед итератором.
- В данном случае if-else это не фильтр перед выполнением выражения, а ветвление самого выражения, то есть переменная уже прошла фильтр, но в зависимости от условия может быть обработана по-разному!

```python
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]list_b = [x if x < 0 else x**2 for x in list_a]# Если x-отрицательное - берем x, в остальных случаях - берем квадрат xprint(list_b)   # [-2, -1, 0, 1, 4, 9, 16, 25]
```


## Периодичность и частичный перебор
### Работа с enumerate()
  1. Возможны два варианта вызова функции enumerate():
    
    - enumerate(iterator) без второго параметра считает с 0.
    - enumerate(iterator, start) — начинает считать с значения start. Удобно, например, если нам надо считать с 1, а не 0.
      
    
2. enumerate() возвращает **кортеж** из порядкового номера и значения текущего элемента итератора. Кортеж в выражении-генераторе результате можно получить двумя способами:
    
    - (i, j) for i, j in enumerate(iterator) — скобки в первой паре нужны!
    - pair for pair in enumerate(mylist) — мы работаем сразу с парой
      
    
3. Индексы считаются для **всех обработанных элементов**, без учета прошли они в дальнейшем условие или нет!  
    
    ```
    first_ten_even = [(i, x) for i, x in enumerate(range(10)) if x % 2 == 0]print(first_ten_even)   # [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)]
    ```
      
    
4. Функция enumerate() не обращается к каким-то внутренним атрибутам коллекции, а просто реализует **счетчик обработанных элементов**, поэтому ничего не мешает ее использовать для неупорядоченных коллекций не имеющих индексации.  
      
    
5. Если мы ограничиваем количество элементов включенных в результат по enumerate() счетчику (например if i < 10), то итератор будет все равно **обработан целиком**, что в случае огромной коллекции будет очень ресурс-затратно. Решение этой проблемы рассматривается ниже в под-разделе «Перебор части итерируемого».


### Перебор части итерируемого.
Выходом может быть использование функции **islice()** из пакета **itertools**.  
  

```python
import itertoolsfirst_ten = (itertools.islice((x for x in range(1000000000) if x % 2 == 0), 10))print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```
