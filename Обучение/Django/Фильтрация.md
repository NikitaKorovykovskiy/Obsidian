`filter(**kwargs)`
`Entry.objects.filter(pub_date__year=2006)`

Возвращает новые QuerySet содержащие объекты, соответствующие заданным параметрам поиска.

`exclude(**kwargs)`
Возвращает новые [QuerySet] содержащие объекты, которые ==_не_ соответствуют== заданным параметрам поиска.

Результат выполнения Queryset является Queryset. Поэтому и можно объединять

##### Каждый Queryset уникален

Каждый раз, когда вы дорабатываете a [`QuerySet`](https://djangodoc.ru/3.2/ref/models/querysets/#django.db.models.query.QuerySet "django.db.models.query.QuerySet"), вы получаете новый [`QuerySet`](https://djangodoc.ru/3.2/ref/models/querysets/#django.db.models.query.QuerySet "django.db.models.query.QuerySet"), никоим образом не связанный с предыдущим [`QuerySet`](https://djangodoc.ru/3.2/ref/models/querysets/#django.db.models.query.QuerySet "django.db.models.query.QuerySet"). Каждое уточнение создает отдельный и неповторимый элемент, [`QuerySet`](https://djangodoc.ru/3.2/ref/models/querysets/#django.db.models.query.QuerySet "django.db.models.query.QuerySet")который можно хранить, использовать и повторно использовать.

Пример:

>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())

##### Ограничение `QuerySet`

Используйте подмножество синтаксиса нарезки массивов Python, чтобы ограничить вас [`QuerySet`] определенным количеством результатов. Это эквивалент предложений `LIMIT`и `OFFSET`предложений SQL .

Например, это возвращает первые 5 объектов ( ):`LIMIT 5`

>>> Entry.objects.all()[:5]

Это возвращает объекты с шестого по десятый ( ):`OFFSET 5 LIMIT 5`

>>> Entry.objects.all()[5:10]

##### Поиск, охватывающий отношения (поиск по связям)

Django предлагает мощный и интуитивно понятный способ «следить» за отношениями при поиске, `JOIN`автоматически заботясь о SQL за кулисами. Чтобы охватить взаимосвязь, используйте имя поля связанных полей в моделях, разделенное двойным подчеркиванием, пока не дойдете до нужного поля.

В этом примере извлекаются все `Entry`объекты с `Blog`которого `name` является :`'Beatles Blog'`

>>> Entry.objects.filter(blog__name='Beatles Blog')

Этот охват может быть сколь угодно глубоким.

Если вы выполняете ==фильтрацию по нескольким отношениям==, и одна из промежуточных моделей не имеет значения, которое соответствует условию фильтрации, Django будет рассматривать ее, как если бы там был пустой (все значения `NULL`), но действительный объект. Все это означает, что никаких ошибок возникать не будет. Например, в этом фильтре:

>Blog.objects.filter(entry__authors__name='Lennon')

##### Составные многозначные отношения
Когда вы фильтруете объект на основе a [`ManyToManyField`](https://djangodoc.ru/3.2/ref/models/fields/#django.db.models.ManyToManyField "django.db.models.ManyToManyField")или наоборот [`ForeignKey`](https://djangodoc.ru/3.2/ref/models/fields/#django.db.models.ForeignKey "django.db.models.ForeignKey"), есть два разных типа фильтров, которые могут вас заинтересовать. Рассмотрим отношение `Blog`/ `Entry`( `Blog`to `Entry`- это отношение "один ко многим"). Нам может быть интересно найти блоги, в которых есть запись, в заголовке которой есть _«Леннон»,_ и которая была опубликована в 2008 году. Или мы могли бы найти блоги, в которых есть запись с _«Леннон»_ в заголовке, а также запись, которая был опубликован в 2008 году. Поскольку с одним связано несколько записей `Blog`, оба этих запроса возможны и имеют смысл в некоторых ситуациях.

Такая же ситуация возникает с файлом [`ManyToManyField`](https://djangodoc.ru/3.2/ref/models/fields/#django.db.models.ManyToManyField "django.db.models.ManyToManyField"). Например, если `Entry`есть [`ManyToManyField`](https://djangodoc.ru/3.2/ref/models/fields/#django.db.models.ManyToManyField "django.db.models.ManyToManyField")вызываемый объект `tags`, мы можем захотеть найти записи, связанные с тегами, называемыми _«музыка»_ и _«группы»,_ или нам может потребоваться запись, содержащая тег с именем _«музыка»_ и статусом _«общедоступный»._ .

Это может показаться немного запутанным, поэтому, надеюсь, прояснит ситуацию. Чтобы выбрать все блоги, которые содержат записи как со словом _«Lennon»_ в заголовке, так и опубликованные в 2008 году (одна и та же запись удовлетворяет обоим условиям), мы должны написать:

>Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)

Чтобы выбрать все блоги, которые содержат запись со _словом «Леннон»_ в заголовке, **а также** запись, опубликованную в 2008 году, мы должны написать:

>Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)

Предположим, что есть только один блог, в котором есть как записи, содержащие _«Леннон», так_ и записи из 2008 года, но ни одна из записей из 2008 года не содержит _«Леннон»_ . Первый запрос не вернет никаких блогов, но второй запрос вернет этот единственный блог.

Во втором примере первый фильтр ограничивает набор запросов всеми теми блогами, которые связаны с записями с _«Lennon»_ в заголовке. Второй фильтр ограничивает множество блогов _дополнительных_ к тем , которые также связаны с записями , которые были опубликованы в 2008 году записи , выбранные с помощью второго фильтра , может или не может быть таким же , как записи в первом фильтре. Мы фильтруем `Blog`элементы с помощью каждого оператора фильтра, а не `Entry`элементы.

##### Фильтры могут ссылаться на поля в модели 

В приведенных выше примерах мы построили фильтры, которые сравнивают значение поля модели с константой. Но что, если вы хотите сравнить значение поля модели с другим полем той же модели?

Django позволяет проводить такие сравнения. Экземпляры выступают в качестве ссылки на поле модели в запросе. Эти ссылки затем можно использовать в фильтрах запросов для сравнения значений двух разных полей в одном экземпляре модели.[`F expressions`](https://djangodoc.ru/3.2/ref/models/expressions/#django.db.models.F "django.db.models.F")`F()`

Например, чтобы найти список всех записей блога, в которых было больше комментариев, чем пингбэков, мы создаем `F()`объект для ссылки на счетчик пингбэков и используем этот `F()`объект в запросе:

>from django.db.models import F
> Entry.objects.filter(number_of_comments__gt=F('number_of_pingbacks'))
##### F()
Django поддерживает использование сложения, вычитания, умножения, деления, по модулю и степенной арифметики с `F()`объектами, как с константами, так и с другими `F()`объектами. Чтобы найти все записи блога с более чем _вдвое_ большим количеством комментариев, чем пингбэков, мы модифицируем запрос:

> Entry.objects.filter(number_of_comments__gt=F('number_of_pingbacks') * 2)

Чтобы найти все записи, в которых рейтинг записи меньше суммы количества ответов и комментариев, мы должны выполнить запрос:

> Entry.objects.filter(rating__lt=F('number_of_comments') + F('number_of_pingbacks'))

Вы также можете использовать нотацию двойного подчеркивания для охвата отношений в `F()`объекте. `F()`Объект с двойным подчеркиванием будет ввести любые объединения , необходимый для доступа связанного объекта. Например, чтобы получить все записи, в которых имя автора совпадает с именем блога, мы могли бы выполнить запрос:

> Entry.objects.filter(authors__name=F('blog__name'))

==Для полей даты и даты / времени вы можете добавить или вычесть== [`timedelta`] объект. Следующее будет возвращать все записи, которые были изменены более чем через 3 дня после их публикации:

> from datetime import timedelta
> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))

##### Копирование экземпляров модели

Хотя нет встроенного метода для копирования экземпляров модели, можно легко создать новый экземпляр со всеми скопированными значениями полей. В простейшем случае, вы можете установить `pk`в `None`и [`_state.adding`](https://djangodoc.ru/3.2/ref/models/instances/#django.db.models.Model._state "django.db.models.Model._state")к `True`. Используя наш пример блога:

```python
blog = Blog(name='My blog', tagline='Blogging is easy')
blog.save() # blog.pk == 1

blog.pk = None
blog._state.adding = True
blog.save() # blog.pk == 2
```
Все усложняется, если вы используете наследование

##### Дополнительные методы для обработки связанных объектов
 - `add(obj1, obj2, ...)`
	Добавляет указанные объекты модели в набор связанных объектов.

 -  `create(**kwargs)`
	Создает новый объект, сохраняет его и помещает в набор связанных объектов. Возвращает вновь созданный объект.

- `remove(obj1, obj2, ...)`
	Удаляет указанные объекты модели из набора связанных объектов.

- `clear()`
	Удаляет все объекты из набора связанных объектов.

- `set(objs)`
	Заменить набор связанных объектов.